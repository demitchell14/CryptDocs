/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import {precacheAndRoute, createHandlerBoundToURL, PrecacheEntry, addRoute} from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

const tinymceRoutes: PrecacheEntry[] = (function() {
	const revision = '1'
	const root = '/tinymce';
	const content = ['dark', 'default']
	const ui = ['oxide', 'oxide-dark']
	const theme = ['silver']

	const contentParts = content.map((c) => ([
		`${root}/skins/content/${c}/content.css`,
		`${root}/skins/content/${c}/content.min.css`,
	])).reduce((a: string[], b: string[]) => (([] as string[]).concat(a, b)))

	const uiParts = ui.map((c) => ([
		`${root}/skins/ui/${c}/content.css`,
		`${root}/skins/ui/${c}/content.min.css`,
		`${root}/skins/ui/${c}/skin.css`,
		`${root}/skins/ui/${c}/skin.min.css`,
	])).reduce((a, b) => (([] as string[]).concat(a, b)))

	const themeParts = theme.map((c) => ([
		`${root}/themes/${c}/index.js`,
		`${root}/themes/${c}/theme.js`,
		`${root}/themes/${c}/theme.min.js`,
	])).reduce((a, b) => (([] as string[]).concat(a, b)))

	return [
		...contentParts,
		...uiParts,
		...themeParts,
	].map((part) => ({
		url: part,
		revision
	}))
})()

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
// eslint-disable-next-line no-underscore-dangle
precacheAndRoute([
	...self.__WB_MANIFEST,
]);


const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
const apiRegExp = new RegExp('/api/');

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }: { request: Request; url: URL }) => {
		// If this isn't a navigation, skip.
		if (request.mode !== 'navigate') {
			return false;
		}

		// If this is a URL that starts with /_, skip.
		if (url.pathname.startsWith('/_')) {
			return false;
		}

		// If this looks like a URL for a resource, because it contains
		// a file extension, skip.
		if (url.pathname.match(fileExtensionRegexp)) {
			return false;
		}

		// if this looks like a URL for an API call, skip
		if (url.pathname.match(apiRegExp)) {
			return false;
		}

		// Return true to signal that we want to use the handler.
		return true;
	},
	createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`)
);

const captureImages = ({ url }: { url: URL }) =>  ['.png', '.jpg', '.gif'].findIndex((u) => url.pathname.endsWith(u)) >= 0

registerRoute(
	({ url }) => {
		const cond = url.pathname.indexOf('/tinymce') >= 0
			&& !captureImages({ url })
		console.log({ cond, url })
		return cond
	},
	new StaleWhileRevalidate({
		cacheName: 'tinymce',
	})
)

registerRoute(
	captureImages,
	// Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: 'images',
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50, purgeOnQuotaError: true }),
		],
	})
);


// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
	if (event.data && event.data.type === 'SKIP_WAITING') {
		self.skipWaiting();
	}
});

// Any other custom service worker logic can go here.
